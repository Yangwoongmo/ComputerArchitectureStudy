# 2023/05/11

소스코드와 명령어

작성한 소스 코드는 바로 컴퓨터가 이해할 수 없다
개발에 쓰이는 C, C++, Python, java 등의 언어는 사람이 개발하기 편하게 만들어진 언어이며
이런 언어를 고급 언어라고 한다

고급 언어를 컴퓨터가 이해할 수 있게 하려면 저급 언어로의 변환이 필요하며
저급 언어는 컴퓨터가 이해하고 실행하는, 직접적인 명령어이다

저급 언어는 크게 기계어와 어셈블리어로 나뉘어져 있는데
기계어는 2진수나 16진수로 표시된다
이런 기계어를 사람이 이해하기 쉽게끔 번역한게 어셈블리어이다

그러면 고급 언어는 어떤 방식으로 저급 언어로 변환되는가
변환에는 크게 컴파일 언어의 컴파일과 인터프리터 언어의 인터프린트 두 방식이 있는데

컴파일의 경우, 고급 언어로 작성한 소스 코드를 컴파일러에 넣어 한번에 전부 저급 언어인 목적 코드로 변환시키는 방식이다
자세하게 들어가면 전처리나 어셈블 등 여러 과정이 들어 있지만, 뒤에 자세히 찾아보기로 하였다
또한 컴파일러가 소스 코드를 전부 살펴보고, 오류나 사용되지 않는 변수 등을 확인해주므로 변환에 어느정도 시간이 걸린다
컴파일러가 전부 훑어보기 때문에, 오류를 찾았을 경우엔 소스 코드를 실행하지 않는다는 특징도 있다

인터프리트의 경우는, 인터프리터라는 프로그램에 의해 소스코드가 한 줄씩 저급 언어로 바뀐다
컴파일과는 달리 한 줄씩 변환을 하므로 소스 코드가 저급 언어로 변환되기까지 기다릴 필요가 없다
또한 한 줄씩 변환하고 실행하기 때문에, 오류가 발생하더라도 오류 이전까지의 코드는 실행이 된다


소스 코드를 어셈블리어로 변환하는 과정은, CPU와 컴파일러의 종류에 따라 같은 소스 코드라도 다른 형식으로 나타낼 수 있다.
또한 모든 언어가 컴파일 언어 / 인터프리터 언어의 흑백으로 딱 나뉘는게 아니고 경계가 애매한 경우가 있기 때문에, 모든 언어가 컴파일 언어, 아니면 인터프리터 언어로 딱 나뉘진 않고, 대표적인 방식이라고 이해하는게 좋을 것 같다



명령어의 구조

명령어의 구조는 수행할 연산을 담은 연산 코드와 연산에 사용될 데이터 혹은 주소가 담긴 오퍼랜드로 나뉘어 있다
오퍼랜드에 연산에 사용될 데이터 주소가 저장되는 경우가 훨씬 많고, 오퍼랜드 필드를 주소 필드라고도 한다

연산 코드가 담고 있는 내용은 CPU마다 다르지만
크게는 다음 4가지가 있다
1. 데이터 전송
2. 산술 / 논리 연산
3. 제어 흐름 변경
4. 입출력 제어

제어 흐름 변경에 CALL과 RETURN 이라는 코드가 있는데
CALL은 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮기는 것이고
RETURN은 CALL을 호출할 때 저장했던 주소로 되돌아가는 것이다

코드에서 함수를 실행할 떄 이 두가지가 실행된다고 한다


오퍼랜드에 주소 값을 담는 경우가 더 많다고 했는데
왜 연산에 사용될 값 자체를 담지 않고 주소 값을 담는가? 라는 의문이 생기는데
이는 명령어 내에서 사용될 수 있는 크기가 제한되기 떄문이다

16bit 크기의 명령어가 있다고 하고, 연산 코드는 이 중에서 4bit를 차지하고 있다
그렇다면 오퍼랜드에 담을 수 있는 크기는 12bit이고, 이는 연산에 필요한 데이터가 많아질수록 1/n이 되어 점점 줄어든다

연산에 사용될 실제 값은 주소 값에 비해서 굉장히 큰 경우가 많기 때문에, 실제 값을 넣어주기 보다는 메모리의 주소 값을 넣어서 해당 주소에 저장된 값을 참조하도록 하는 것이 더 많은 데이터를 표현할 수 있다



명령어 주소 지정 방식

데이터가 어디에 저장되어 있던지 간에, CPU는 연산을 위해서 해당 값을 찾아올 수 있어야 한다
연산에 사용할 데이터가 저장된 위치를 찾는 방법, 혹은 유효 주소를 찾는 방법이다

대표적인 명령어 주소 지정 방식은 다음과 같다

1. 즉시 주소 지정 방식
연산에 사용될 데이터를 오퍼레이터 필드에 직접 명시
가장 간단한 형태의 주소 지정 방식이다 
데이터의 크기에 제한이 걸릴 가능성이 높지만, 연산에 사용될 데이터가 그와 상관없이 작다면 가장 속도가 빠른 방식이기도 하다

2. 직접 주소 지정 방식
오퍼랜드 필드에 데이터 값이 들어간 메모리 주소 값을 넣는 방법이다
데이터의 크기에는 제한이 없지만, 연산 코드의 크기가 커질수록 주소를 넣을 공간이 줄어든다는 단점이 있다

3. 간접 주소 지정 방식
직접 주소 지정 방식의 단점을 보완하여, 데이터가 담긴 주소값을 가리키는 주소값을 명시하는 것이다
다만 유효 주소의 주소 -> 유효 주소 -> 연산에 사용할 데이터 순으로 진행되기 때문에, 속도가 가장 느리다는 단점 또한 존재한다

4. 레지스터 주소 지정 방식
연산에 사용될 데이터가 저장된 '레지스터' 주소를 넣어주는 것이다
CPU에서 메모리를 참조하는 것 보다 레지스터에 접근하는 것이 빠르기 때문에 똑같이 주소를 넣어주더라도 2번에 비해 빠르다는 장점이 있다

5. 레지스터 간접 주소 지정 방식
연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 것이다
3번과 비슷해 보이지만, 메모리 주소를 두번 찾는 것이 아니고, 레지스터 -> 메모리 순으로 이동하기 때문에 3번에 비해 속도가 빠르다


※ CPU가 메모리의 값을 찾는 속도는 굉장히 속도가 느리기 때문에 메모리 접근을 최소화하는것이 속도 면에서는 무조건 좋다
