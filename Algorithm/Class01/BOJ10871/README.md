# 속도 최적화

코드를 맨 처음 짰을 때는 430ms정도가 나왔다
타임아웃은 아니었지만 다른 사람들의 시간을 보자 0ms로 푼 사람들이 수두룩해져 검색을 해 보았는데

ios::sync_with_stdio(false);
cin.tie(NULL);
cout.tie(NULL);

이 세 줄의 코드가 들어가 있는 것을 확인했다
대체 뭐길래 속도를 저렇게 올려 주는 것인가 알아보았다

## ios::sync_with_stdio(false);

### 장점
true일때 c의 stdio와 iostream을 동기화해주는 역할을 한다
이 때, stdio와 iostream의 버퍼를 모두 사용하기 때문에 딜레이가 발생한다고 한다
따라서 false값을 넣어 줄 경우 동기화를 비활성화 할 수 있다

이로 인해 c++만의 독립 버퍼가 생성되어 c의 버퍼와 병행하여 사용할 수 없지만
사용하는 버퍼의 총 개수가 줄어들어서 실행 속도는 빨라지게 된다고 한다

### 단점
동기화된 c++ 버퍼의 경우, tread-safe 하기 때문에, 모든 IO의 순서가 예상한 것과 정확하게 돌아간다
하지만 비동기 처리를 했을 경우에, 멀티 스레드 환경에서는 출력 순서를 보장할 수 없다
또한 버퍼가 분리되었기 때문에, 
cin과 scanf, gets, getchar 
cout과 printf, puts, putchar 
등을 같이 사용하면 엉뚱한 결과가 나올 확률이 높기 때문에 사용을 지양해야 한다고 한다

### 사용
하지만 이 코드에서 ios::sync_with_stdio(false);를 추가하였을 때, 큰 속도 차이를 느끼지 못 했다

그렇다면 답은 아래 두 줄에 있다고 확신했다


## cin.tie(NULL); 과 cout.tie(NULL);

cout.tie(NULL); 코드는 cin과 cout의 묶음을 풀어준다
기본적으로 cin과 cout은 하나로 묶여있고, 묶여있는 스트림들은 한 스트림이 다른 스트림에서 각 IO작업을 진행하기 전에 자동으로 버퍼를 비워줌을 보장한다고 한다

cout << "이름: ";
cin >> name;

이라는 코드가 있다고 해 보자
cin과 cout은 묶여있기 때문에 순차적으로, 이름 :  출력이 된 후, 입력을 받을 것이다
하지만 cin.tie(NULL); 코드를 추가한다면, 묶음이 풀리면서 순서를 무시하고, 출력 전에 입력을 받는 상황이 생길 수도 있다

이는 cout이 기본적으로 버퍼에 추가된 후, 출력 명령이나 버퍼가 가득 찬 경우가 아니라면 바로 비워지지 않기 때문이다
따라서 위 코드를 추가한 후 순차적으로 진행을 하고 싶다면, cout으로 출력할 때 버퍼를 비워줘야한다고 한다


## 결론

알고리즘은 보통 싱글 스레드 환경이기 때문에 ios_base::sync_with_stdio(false); 를 추가해도 결과에 영향을 주지 않고, 오히려 속도가 빨라진다
다만 c와 c++ 스타일 입출력문 혼용에 주의해야한다

기본적으로 cin으로 읽을 때 먼저 출력 버퍼를 비우는데, 마찬가지로 알고리즘을 풀 때는 화면에 바로 보이는 것이 중요하지 않다
따라서 입출력을 여러번 반복해야 하는 경우, 필수적으로 cin.tie(NULL); 코드를 추가하여 묶음을 풀어주는게 효과적인 속도 향상의 원인이 될 수 있다
